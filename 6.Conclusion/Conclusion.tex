%!TEX root = ../Fast_Contour_Tracing_Algorithm.tex
% -*- root: ../Fast_Contour_Tracing_Algorithm.tex -*-

\section{Conclusion}

% In this paper, we proposed a contour tracing algorithm to trace contours in low-performance devices such as mobile phones, PDAs, and embedded devices that have a processor with limited computational capability and a small memory capacity. The proposed algorithm traces contour pixels based on the pixel following method, and it can also convert the contour information to compressed data and accurately restore it to the original contour by using the vertex following method. The proposed algorithm repeatedly executes the two tracing stages. first, the tracer moves to the next pixel based on its left and left-rear pixels. Next, it moves based on the front and front-left pixels. With these pixel pairs, the contour pixel can be classified into four types, namely, inner corner, outer corner, inner-outer corner, and straight line, and 
% this classification is used to reduce the computational time for tracing the next contour pixel without duplicated detection of the background pixel. Moreover, based on the classified cases, we can determine the representative points and the inner-outer corner points that are based on the coordinates of the vertices, and we can store the contour data as points in order to reduce the data size. In addition, we proposed a restoration algorithm to retrieve all the contour pixels from the representative points and the inner-outer corner points. It performs accurate restoration and it can also restore the inner-outer corners that were not considered in conventional algorithms such as the RD code method and the PXY method. Another characteristic of the proposed algorithm is that it can trace the desired type of connectivity since it is able to distinguish between the connection types of the contour pixels. For example, the proposed algorithm may trace without inner corners, which is similar to the performance of MNT and RSA.

In this paper, we proposed a contour-tracing algorithm to trace contours in low-performance devices such as mobile phones, PDAs, and embedded devices that have a processor with limited computational capability and a small memory capacity. The proposed algorithm traces contour pixels based on the pixel-following method, and it can also convert the contour information to compressed data and accurately restore it to the original contour using the vertex-following method. The proposed algorithm repeatedly executes the two tracing stages. First, the tracer moves to the next pixel based on its left and left-rear pixels. Next, it moves based on the front and front-left pixels. \JHMEMO{With these two tracing stages, the proposed algorithm extracts two contiguous contour pixels together. Because the proposed algorithm traces contiguous pixel pairs in a single step, there are more possible cases of the form a contour can take. Therefore the classification of the contour is more complicated than the conventional algorithms. On the other hand, this classification actually takes less time to compute, because it reduces duplicated detection of the background pixels.} Moreover, based on the classified cases, we can determine the representative points and the inner-outer corner points that are based on the coordinates of the vertices, and we can store the contour data as points in order to reduce the data size. In addition, we proposed a restoration algorithm to retrieve all of the contour pixels from the representative points and the inner-outer corner points. The proposed algorithm performs accurate restoration, and it can restore the inner-outer corners that were not considered in conventional algorithms such as the RD code method and the PXY method. Another characteristic of the proposed algorithm is that it can trace the desired type of connectivity because it is able to distinguish between the different types of connections of the contour pixels. For example, the proposed algorithm may trace without inner corners, which is similar to the performances of MNT and RSA.

% Because the proposed algorithm traces contiguous pixel pairs in a single step, there are more possible cases of the form a contour can take. Therefore the classification step of the contour may be more complicated than the conventional algorithms. On the other hand, this classification process actually takes less time to compute and trace the next contour pixel by reducing the number needed to detect background pixel since it checks values of two pixels at once. <- 정현이

%  Although the entire contour cases are more sophisticated than the conventional algorithms, the proposed algorithm traces 

% Although the proposed algorithm traces two contour pixels at once, 

% 연속된 점을 


%   % 이렇게 두 점을 한번에 trace 하면서 각 contour 픽셀을 4가지 타입으로 구분한다. 제안하는 방법은, 8가지 케이스로 2 점을 한 stage 에 trace 하기 때문에 설계는 복잡하지만, backgroun pixel 의 중복 detection을 줄일 수 있기 때문에 기존 알고리즘들에 비하여 높은 성능을 제공한다. 


%  With these pixel pairs, the contour pixels can be classified as four types, namely, inner corner, outer corner, inner-outer corner, and straight line. 

% , and we used these classifications to reduce the computational time required for tracing the next contour pixel without duplicated detection of the background pixel. Moreover, based on the classified cases, we can determine the representative points and the inner-outer corner points that are based on the coordinates of the vertices, and we can store the contour data as points in order to reduce the data size. In addition, we proposed a restoration algorithm to retrieve all of the contour pixels from the representative points and the inner-outer corner points. The proposed algorithm performs accurate restoration, and it can restore the inner-outer corners that were not considered in conventional algorithms such as the RD code method and the PXY method. Another characteristic of the proposed algorithm is that it can trace the desired type of connectivity because it is able to distinguish between the different types of connections of the contour pixels. For example, the proposed algorithm may trace without inner corners, which is similar to the performances of MNT and RSA.

% We experimented with regard to three aspects-accuracy, speed, and saving data. In the results of the experiments, the proposed algorithm had the best performance with regard to the accuracy of contour tracing, i.e., it traced the largest number of contour pixels among the algorithms. Moreover, it showed the least average processing time per contour pixel and good performance with respect to the processing time of each image and the LSE. For this reason, it has reasonable performance and based on accuracy and processing time, it is regarded as the best among the algorithms. The proposed algorithm showed good performance with regard to not only the accuracy and speed but also the memory consumption. It stored only the representative points and inner-outer corner points; therefore, it reduced the memory consumption. Besides, the proposed restoration algorithm successfully retrieved all the contour pixels from the compressed data. Therefore, the proposed algorithm shows improved accuracy and fast processing of contour tracing, low memory consumption for saving the contour, and good restoration ability.

We performed experiments with regard to three aspects-accuracy, speed, and saving data. From the experiment results, the proposed algorithm had the best performance with regard to the accuracy of contour tracing, i.e., of all the algorithms, it traced the largest number of contour pixels. Moreover, it had the smallest average processing time per contour pixel and good performance with respect to the processing time of each image and the LSE. For this reason, it is considered to have reasonable performance, and based on its accuracy and processing time, it is regarded as the best of the different algorithms. In addition to the accuracy and speed, the proposed algorithm exhibited good performance with regard to the memory consumption. It stored only the representative points and inner-outer corner points, thus reducing the memory consumption. Besides, the proposed restoration algorithm successfully retrieved all the contour pixels from the compressed data. Therefore, the proposed algorithm shows improved accuracy and fast processing of contour tracing, low memory consumption for saving the contour, and good restoration ability.